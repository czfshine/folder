# folder
一个工具，对文件夹内的每个文件/目录进行描述(备注）
>下面是一大堆啰里啰唆的话，想看安装教程直接滚到最后

 不知你们有没有这样的感受，一堆文件在创建时是随机创建的，经过一段时间后，全然忘记这堆文件是干嘛的，怎么用。所以要写一些说明表示这些文件的相关信息，写这个项目的目的是方便创建查看整理这些信息，提供一个规范。

**首先先确定要保存的信息**

* 最简单最基本的就是文件名和一个说明字符串
* 然后还可以加一些额外的信息，比如忽略某个文件夹或其内容
  * `.git` `.vscode` 这些众所周知的文件夹，
  * 或者是有着大量数据文件的文件夹，如微信聊天记录的图片文件夹，里面有超大量的小文件和文件夹，分析这些文件会严重拖慢程序的执行速度
  * 还有就是一些不关心其组成的文件夹，比如程序的安装目录，我们只要知道这个文件夹是这个程序的就行，里面的组织形式我们不在乎
* 说明字符串应该简短，而我们可能想描述这些文件的使用方法需要一个长字符串，那么这个字符串要和说明字符串区别开来
* 同时可以加些用户自定义的信息，比如这个文件夹内有隐私文件（那么用户可以使用特定的功能将其删除），或者是该文件夹的重要程度（我们在备份时要先备份重要的，那些可有可无的可以不用备份或者只保留一个副本）


本程序会在每个（需要说明的）文件夹下生成一个名为`FOLDER.MD`的描述文件，文件示例看本项目的[FOLDER.MD](.\FOLDER.MD).

# 为什么使用FOLDER.MD存放信息

现在有两种保存信息的方式，集中式存放或者分布式存放。集中式是指将所有的文件描述存放在唯一的数据文件里面，这样的好处是不用破坏原始的文件结构，但是，要同步这些信息较为麻烦。
比如，要移动文件夹，显然这些信息要跟随文件夹移动，但是，在外部使用文件管理器或mv命令移动文件夹，对这些信息的管理程序(指本项目)是无法捕获到这些动作的。也就造成信息的缺失。而采用每个文件夹独立的数据文件，这些数据会跟随文件夹而移动，管理程序要更新信息的话，只需读取文件夹下的数据文件即可。
而且，这样还有下列好处：

* 可跟随文件夹进行打包发布
    假如现在将文件夹打包成压缩包，在该文件夹下的FOLDER.MD文件也会随之被打包，经过传输，在任意电脑上都可以被读取。同样也适用于网盘同步什么的。

# 为什么使用Markdown
考虑有另外的人打开你发送给他的文件夹，他并没有安装本工具，而他想读取说明信息的话，以纯文本保存最好。
当然，纯文本数据有着常用的xml和json这些，为什么使用较难解析的Markdown？
首先，它是对人类友好的格式。基本上文件内容对非程序员也可以猜得八九不离十，而且越来越多编辑器支持Markdown了，比如在github上直接打开md文件即可看到渲染后的内容。

但是，使用Markdown有个缺点，解析难度大，它不像xml，json那样是为数据传输存储而设计的，扩展能力弱，就像上面所说的要加额外信息，我的做法是使用`（反引号）包裹

# Markdown 文件结构
> 使用类BNF范式描述 ：[] 指可选，| 指`或` ，`*` 开头的不是结构快

```assembly
DataFile ::=[HEAD] DIRINFO   [DIRS]  [FILES] [OPS] 
DIRINFO  ::= dirname dirdesc dirusage
DIIRS    ::= dirmark   dir
FILES    ::= filemark  file
dir      ::= dir dir | line |""
file     ::= file file |line |""

; 从这里开始看起
HEAD 	 ::= YAMLformatted  ;Markdown额外的信息
dirname  ::= *MarkdownH1	;文件夹名
dirdesc  ::= *MarkdownQuoting	;文件夹说明

;这个文件夹内容的使用说明，直到遇见dirmark（子文件夹描述开始标记为止）
dirusage ::= *MarkdownText *until dirmark 
;子文件夹描述开始标记，从这里开始下面就是子文件夹的描述
dirmark  ::= *MarkdownH1 *MarkdownQuoting 
line     ::= *todo ;一行就是一个文件夹
filemark ::= *MarkdownH1 *MarkdownQuoting ;子文件描述开始
OPS      ::= *todo ;可选的而外信息
```
# Usage

> 预期设计效果，还没成功

* 安装`fl.sh`或`fl.bat` 到PATH里，即可在任意地方使用

* 在文件夹内不带参数运行`fl` 命令，将类似ll的输出效果，但是每个文件还后面都会接上你编写的注释
* 运行`fl [filename]`将会显示一个**可编辑**的行，默认内容为上一次的注释，可修改，回车写入`FOLDER.MD` 文件

* 其他工具查看`fl --help`
# Install

> 理论上适用在`luaFileSystem`（用来列文件）能被载入的系统都可以使用（其他都是纯lua）,[todo]抽象文件系统接口.

* 安装lua 与lfs
* clone
* `lua install.lua`
* 完事 

# 适用环境

只要有LuaFileSystem库的系统都可以使用，适用`lua 5.1 lua 5.2 lua 5.3 luajit` 等解释器。